<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinetic Particle Wave</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 12px;
        }
        .instruction {
            margin-top: 8px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
        }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui">
        <div>Kinetic Field</div>
        <div class="instruction">Move mouse to disturb â€¢ Scroll to zoom</div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const PARTICLE_COUNT_X = 150; // Grid resolution width
        const PARTICLE_COUNT_Z = 150; // Grid resolution depth
        const SEPARATION = 1.2;
        
        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510); // Deep dark blue-black
        scene.fog = new THREE.FogExp2(0x050510, 0.0025);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 80, 120);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxDistance = 300;
        controls.minDistance = 20;

        // --- Particle System (ShaderMaterial) ---
        // Using shaders for high performance thousands of particles

        const particlesGeometry = new THREE.BufferGeometry();
        const count = PARTICLE_COUNT_X * PARTICLE_COUNT_Z;
        
        const positions = new Float32Array(count * 3);
        const scales = new Float32Array(count);
        const offsets = new Float32Array(count); // Random offset for phase

        let i = 0;
        for (let ix = 0; ix < PARTICLE_COUNT_X; ix++) {
            for (let iz = 0; iz < PARTICLE_COUNT_Z; iz++) {
                
                // Center the grid
                const x = (ix - PARTICLE_COUNT_X / 2) * SEPARATION;
                const z = (iz - PARTICLE_COUNT_Z / 2) * SEPARATION;
                const y = 0;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                scales[i] = 1;
                offsets[i] = Math.random() * Math.PI * 2; // Random phase

                i++;
            }
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        particlesGeometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1));

        // Vertex Shader
        const vertexShader = `
            uniform float uTime;
            uniform float uMouseX;
            uniform float uMouseY;
            uniform float uIntensity; // Mouse interaction intensity
            
            attribute float aOffset;
            attribute float scale;

            varying vec3 vColor;
            varying float vDist;

            // Color palette function
            vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {
                return a + b*cos( 6.28318*(c*t+d) );
            }

            void main() {
                vec3 newPosition = position;

                // --- Wave Logic ---
                // Distance from center allows for ripple effects
                float dist = distance(newPosition.xz, vec2(0.0));
                
                // Complex wave function
                // Base wave
                float y = sin(newPosition.x * 0.1 + uTime * 1.5 + aOffset) * 2.0; 
                y += cos(newPosition.z * 0.08 + uTime * 1.2) * 2.0;
                
                // Secondary detailed wave
                y += sin(dist * 0.15 - uTime * 2.0) * 3.0;

                // Mouse Interaction Ripple (simplified as a global height modifier based on mouse position relative to center of screen - actually passed as uniform intensity)
                y *= (1.0 + uIntensity * 2.0); 

                newPosition.y = y;

                vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );
                gl_Position = projectionMatrix * mvPosition;

                // Size attenuation
                gl_PointSize = scale * ( 200.0 / - mvPosition.z );
                
                // --- Coloring ---
                // Create a beautiful gradient based on height
                // Colors: Cyan -> Purple -> Pink
                // map y from [-5, 5] to [0, 1] roughly
                float heightFactor = smoothstep(-8.0, 8.0, y);
                
                // https://iquilezles.org/articles/palettes/
                // Electric Blue/Purple palette
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.30, 0.20, 0.20); 

                // Dynamic coloring: Mix a base color with a hot color based on height/speed
                vec3 colorLow = vec3(0.1, 0.4, 0.8); // Deep Blue
                vec3 colorHigh = vec3(0.2, 0.8, 1.0); // Cyan
                vec3 colorPeak = vec3(0.9, 0.2, 0.8); // Magenta
                
                vColor = mix(colorLow, colorHigh, heightFactor);
                vColor = mix(vColor, colorPeak, smoothstep(0.7, 1.0, heightFactor));
                
                // Add extra brightness based on mouse intensity
                vColor += vec3(uIntensity * 0.3);

                vDist = dist; // Pass distance to fragment
            }
        `;

        // Fragment Shader
        const fragmentShader = `
            varying vec3 vColor;
            
            void main() {
                // Circular particle shape from PointCoord
                float r = distance( gl_PointCoord, vec2(0.5));
                if ( r > 0.5 ) discard;

                // Soft glow
                float glow = 1.0 - (r * 2.0);
                glow = pow(glow, 1.5);

                gl_FragColor = vec4( vColor, glow );
            }
        `;

        const particlesMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uIntensity: { value: 0 }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending // Glowy effect
        });

        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);

        // --- Interaction ---
        const mouse = new THREE.Vector2();
        let targetIntensity = 0;

        window.addEventListener('mousemove', (event) => {
            // Normalize mouse -1 to 1
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Interaction: if mouse moves fast or is near center, increase intensity? 
            // Let's just use distance from center of screen for simplicity roughly
            // Or just map Y position to intensity
            targetIntensity = (mouse.y + 1) * 0.5; // Simple slider from bottom to top
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();

            // Update uniforms
            particlesMaterial.uniforms.uTime.value = elapsedTime;
            
            // Smoothly interpolate intensity
            particlesMaterial.uniforms.uIntensity.value = THREE.MathUtils.lerp(
                particlesMaterial.uniforms.uIntensity.value,
                targetIntensity,
                0.05
            );

            // Rotate system slightly if idle? Controls handles strict rotation.
            controls.update();

            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>
