<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinetic Particle Wave</title>
    <!-- Modern Font -->
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Outfit', sans-serif;
        }

        canvas {
            display: block;
        }

        /* Glassmorphism UI Panel */
        #ui-panel {
            position: absolute;
            top: 24px;
            left: 24px;
            width: 280px;
            padding: 24px;
            background: rgba(20, 20, 30, 0.4);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            color: #fff;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        h1 {
            margin: 0 0 8px 0;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 1px;
            background: linear-gradient(90deg, #fff, #a2d2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            margin: 0 0 24px 0;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.4;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .label-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 11px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]:focus {
            outline: none;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        input[type=range]::-webkit-slider-thumb {
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #4cc9f0;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -5px;
            box-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
            transition: transform 0.1s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #fff;
        }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="ui-panel">
        <h1>KINETIC WAVE</h1>
        <p>Classic Ocean Mode. Mouse height controls energy.</p>

        <div class="control-group">
            <div class="label-row">
                <span>Wave Speed</span>
                <span id="val-speed">1.0</span>
            </div>
            <input type="range" id="input-speed" min="0" max="3" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <div class="label-row">
                <span>Base Height</span>
                <span id="val-height">1.0</span>
            </div>
            <input type="range" id="input-height" min="0" max="3" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <div class="label-row">
                <span>Glow Intensity</span>
                <span id="val-bloom">1.5</span>
            </div>
            <input type="range" id="input-bloom" min="0" max="3" step="0.1" value="1.5">
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const cfg = {
            speed: 1.0,
            heightScale: 1.0,
            bloomStrength: 1.5
        };

        const PARTICLE_COUNT_X = 200;
        const PARTICLE_COUNT_Z = 200;
        const SEPARATION = 1.0;

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        scene.fog = new THREE.FogExp2(0x020205, 0.002);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 70, 120);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", stencil: false, depth: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxDistance = 400;
        controls.minDistance = 20;

        // --- Post Processing ---
        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.0;
        bloomPass.strength = cfg.bloomStrength;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Starfield Background ---
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 4000;
        const starPos = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);
        for (let i = 0; i < starCount * 3; i++) {
            starPos[i] = (Math.random() - 0.5) * 800;
            if (i % 3 === 0) starSizes[i / 3] = Math.random();
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.8,
            transparent: true,
            opacity: 0.6,
            sizeAttenuation: true
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);


        // --- Kinetic Wave Particles ---
        const particlesGeometry = new THREE.BufferGeometry();
        const count = PARTICLE_COUNT_X * PARTICLE_COUNT_Z;

        const positions = new Float32Array(count * 3);
        const scales = new Float32Array(count);
        const offsets = new Float32Array(count);

        let i = 0;
        for (let ix = 0; ix < PARTICLE_COUNT_X; ix++) {
            for (let iz = 0; iz < PARTICLE_COUNT_Z; iz++) {

                const x = (ix - PARTICLE_COUNT_X / 2) * SEPARATION;
                const z = (iz - PARTICLE_COUNT_Z / 2) * SEPARATION;
                const y = 0;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                scales[i] = 1;
                offsets[i] = Math.random() * Math.PI * 2;

                i++;
            }
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        particlesGeometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1));

        // Vertex Shader - REVERTED TO CLASSIC WAVE
        const vertexShader = `
            uniform float uTime;
            uniform float uIntensity; // Global Intensity (Mouse Y)
            uniform float uHeightScale;
            
            attribute float aOffset;
            attribute float scale;

            varying vec3 vColor;

            void main() {
                vec3 newPosition = position;

                float dist = distance(newPosition.xz, vec2(0.0));
                
                // --- Classic Complex Wave Function ---
                // Primary Sine
                float y = sin(newPosition.x * 0.1 + uTime * 1.5 + aOffset) * 2.0; 
                // Secondary Cosine crossing
                y += cos(newPosition.z * 0.08 + uTime * 1.2) * 2.0;
                // Ripple from center
                y += sin(dist * 0.15 - uTime * 2.0) * 3.0;

                // Modifiers
                y *= uHeightScale;
                // Global Interaction: Mouse boosts the entire wave height
                y *= (1.0 + uIntensity * 2.0); 

                newPosition.y = y;

                vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );
                gl_Position = projectionMatrix * mvPosition;

                // Size attenuation
                gl_PointSize = scale * ( 250.0 / - mvPosition.z );
                
                // --- Coloring ---
                float heightFactor = smoothstep(-10.0, 15.0, y);
                
                vec3 colorDeep = vec3(0.02, 0.02, 0.1);    // Void Purple
                vec3 colorMid  = vec3(0.0, 0.5, 0.8);      // Electric Blue
                vec3 colorHigh = vec3(0.0, 1.0, 0.9);      // Cyan
                vec3 colorPeak = vec3(0.8, 0.1, 0.6);      // Magenta Hot

                vec3 finalColor = mix(colorDeep, colorMid, smoothstep(0.0, 0.4, heightFactor));
                finalColor = mix(finalColor, colorHigh, smoothstep(0.4, 0.7, heightFactor));
                finalColor = mix(finalColor, colorPeak, smoothstep(0.8, 1.0, heightFactor));
                
                // Brighten on high intensity
                finalColor += vec3(uIntensity * 0.3);

                vColor = finalColor;
            }
        `;

        // Fragment Shader
        const fragmentShader = `
            varying vec3 vColor;
            
            void main() {
                float r = distance( gl_PointCoord, vec2(0.5));
                if ( r > 0.5 ) discard;

                float alpha = 1.0;
                if(r > 0.3) alpha = 1.0 - smoothstep(0.3, 0.5, r);

                gl_FragColor = vec4( vColor, alpha );
            }
        `;

        const particlesMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uIntensity: { value: 0 },
                uHeightScale: { value: 1.0 }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);

        // UI Binding
        const uiSpeed = document.getElementById('input-speed');
        const uiHeight = document.getElementById('input-height');
        const uiBloom = document.getElementById('input-bloom');

        uiSpeed.addEventListener('input', (e) => {
            cfg.speed = parseFloat(e.target.value);
            document.getElementById('val-speed').innerText = cfg.speed.toFixed(1);
        });
        uiHeight.addEventListener('input', (e) => {
            cfg.heightScale = parseFloat(e.target.value);
            document.getElementById('val-height').innerText = cfg.heightScale.toFixed(1);
        });
        uiBloom.addEventListener('input', (e) => {
            cfg.bloomStrength = parseFloat(e.target.value);
            bloomPass.strength = cfg.bloomStrength;
            document.getElementById('val-bloom').innerText = cfg.bloomStrength.toFixed(1);
        });


        // Global Mouse Interaction (Classic)
        let targetIntensity = 0;
        window.addEventListener('mousemove', (event) => {
            // Normalize Mouse Y [0, 1]
            let y = 1.0 - (event.clientY / window.innerHeight);
            targetIntensity = y;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            time += delta * cfg.speed;

            particlesMaterial.uniforms.uTime.value = time;
            particlesMaterial.uniforms.uHeightScale.value = cfg.heightScale;

            // Lerp intensity
            particlesMaterial.uniforms.uIntensity.value = THREE.MathUtils.lerp(
                particlesMaterial.uniforms.uIntensity.value,
                targetIntensity,
                0.05
            );

            stars.rotation.y = time * 0.02;

            controls.update();
            composer.render();
        }

        animate();
    </script>
</body>

</html>